\chapter{LuaTeX}
\addtocimage{-10pt}{-40pt}{./images/tocblock-lua.JPG}

\section{What is LuaTeX}

Although \tex and \latexe can be used to program complex commands, and the proof is this book, they are not  general programming languages. Many tasks that can easily be carried out
in other programming languages, are extrememely complicated or very slow when done with \tex. Due to this limitation many auxiliary programs have been developed to assist in common tasks, such as |bibtex| or |biber| that are used to build bibliographies and |makeindex| or |xindy| to generate indexes. In both cases, sorting a list alphabetically is a relatively easy task, but very complicated using \tex.


Another limitation is \tex's math capabilities. One can just marvel at the efforts of \tex macro authors in achieving what they have achieved. A cursory look at the code in the \pkgname{fp} package \footfullcite{fp} can give you an idea of the difficulties and complexities involved. The similarly named package by the \latex3 Team is another gigantic and amazing production.

To address the need to do more complex functions within \TeX, an extension of \TeX{} called Lua\TeX{} started a few years ago.  
(The leaders of the project and main developers are Taco Hoekwater, Hartmut Henkel and Hans Hagen.) The idea was to enhance \TeX{} with a previously existing general purpose programming language. After a careful evaluation of possible candidates, the language chosen was Lua (see \href{http://www.lua.org/}{lua.org}), a powerful, fast, lightweight, embeddable scripting language that has,  of course, a free license suitable to be used with \TeX. It is a pity that at the time |Go| was not available, as it would have been a perfect languge to interface with \tex and perhaps eventually rre-write the original program into a new language.

Lua is considered an easy to learn and use language. Anyone with basic programming skills can use it without difficulty. (Many examples of Lua code can be found in this book, and also in \href{http://rosettacode.org/wiki/Category:Lua}{rosettacode.com},
and \url{http://lua-users.org/}).

Lua\TeX{} is not \TeX{}, but an extension of \TeX{}, in the same way that pdf\TeX{} or \XeTeX{} are also extensions.
In fact, Lua\TeX{} includes pdf\TeX{} (it is an extension of pdf\TeX{}, and offers backward compatibility), 
and also has many of the features of \XeTeX.

Lua\TeX{} is now in a beta stage, but the current versions are usable (the first public beta was launched in 2007,
and when this paper was written on \today, the release used was version 1.\the\luatexversion). 

\section{Is LuaTeX for you?}

The choice of TeX engine should in a way be immaterial to you, if you are just thinking about typesetting normal books. If you are writing a thesis or you are involved with a longer and more complex document, \lualatex might be for you. 

\section{Embedding Lua in a TeX document}

Short Lua code can be embedded in a document fairly easily with 
\begin{docCommand}{directlua}{\marg{code}}
Although it is recommended to put Lua code in Lua files, from time to time one may want or need to go Lua in the middle of a document. To this end, LuaTeX has two commands: \cmd{\directlua} and \cmd{\latelua}. They work the same, except \cmd{\latelua} is processed when the page where it appears is shipped out, whereas \cmd{\directlua} is processed at once; the distinction is immaterial here, and what is said of \cmd{\directlua} also applies to \cmd{\latelua}.
\end{docCommand}

\section{From Lua to TeX}

There are a number of commands that can be used to pass code and values from Tex to Lua and vice-versa.

\begin{docCommand}{tex.print}{\meta{material}}
\end{docCommand}

Inside Lua code, one can pass strings to be processed by \TeX\ with the functions |tex.print()|, |tex.sprint()| and |tex.tprint()|. All such calls are processed at the end of a \refCom{directlua} call, even though they might happen in the middle of the code. This behavior is worth noting because it might be surprising in some cases, although it is generally harmless.

The function can also can also take an optional number as its first argument; it is interpreted as referring to a catcode table (as defined by \docAuxCommand{initcatcodetable} and \docAuxCommand{savecatcodetable}), and each line is processed by TeX with that catcode regime. For instance (note that with such a minimal catcode table, braces don't even have their usual values):

\begin{texexample}{catcodes}{lua:catcodes}
\directlua {tex.enableprimitives('',tex.extraprimitives()) }
\bgroup
\initcatcodetable1
\catcode`\_=0
\savecatcodetable1
\egroup
\directlua{tex.print(1, "_TeX")}
\luadirect{tex.print(1, "_TeX")}
\end{texexample}

The string will be read with |_| as an escape character, and thus interpreted as the command commonly known as |\TeX|. The catcode regime holds only for the strings passed to |tex.print()| and the rest of the document isn't affected.

If the optional number is -1, or points to an invalid (i.e. undefined) catcode table, then the strings are processed with the current catcodes, as if there was no optional argument. If it is -2, then the strings are read as if the result of \cmd{\detokenize}: all characters have catcode 12 (i.e. `other', characters that have no function beside representing themselves), except space, which has catcode 10 (as usual).


Note the |\directlua {tex.enableprimitives('',tex.extraprimitives()) }|, without this directive the extra primitives are not loaded, and the example will produce errors. this is rather hidden in the documention in version 0.\the\luatexversion running under \formatname.


\section{Checking for LuaTeX}

The first thing you will need to program, when developing a \luatex\ package, is to check that the engine is in fact using \luatex. This can be done using the \cs{ifluatex} from the package \pkgname{ifluatex}. 

\begin{texexample}{Checking for Lua}{}
\ifxetex
  Using XeTeX
\else
  \ifluatex
   Using LuaTeX
  \else
   Using LaTeX
  \fi
\fi
\end{texexample}


%---------------
\begin{figure}
\begin{luacode*}
-- Fourier series
function partial_sum(n,x)
    partial = 0;
    for k = 1, n, 1 do 
        partial = partial + math.sin(k*x)/k 
    end;
    return partial
end
-- Code to write PGFplots data as coordinates
function print_partial_sum(n,xMin,xMax,npoints,option)
    local delta = (xMax-xMin)/(npoints-1)
    local x = xMin
    if option~=[[]] then
        tex.sprint("\\addplot["..option.."] coordinates{")
    else
        tex.sprint("\\addplot coordinates{")
    end
    for i=1, npoints do
        y = partial_sum(n,x)
        tex.sprint("("..x..","..y..")")
        x = x+delta
    end
    -- We can write "};" and then it is not necessary to put ";" when used
    tex.sprint("}") 
end
\end{luacode*}
\newcommand\addLUADEDplot[5][]{\directlua{print_partial_sum(#2,#3,#4,#5,[[#1]])}}
\centering
\pgfplotsset{width=15cm, height=7cm}  
\begin{tikzpicture}\small
\begin{axis}[xmin=-0.2, xmax=31.6, ymin=-1.85, ymax=1.85, 
  xtick={0,5,10,15,20,25,30},
  ytick={-1.5,-1.0,-0.5,0.5,1.0,1.5},
  minor x tick num=4,
  minor y tick num=4,
  axis lines=middle,
  axis line style={-}
  ] 
%%\addplot[color=red] {pi/2-x/2};
% SYNTAX: Partial sum 30, from x = 0 to 10*pi, and sampled in 1000 points
\addLUADEDplot[color=blue,smooth]{30}{0}{10*math.pi}{1000};
\end{axis} 
\end{tikzpicture}
\caption{The partial sum $\sum_{k=1}^{30} \frac{\sin(kx)}{k}$ of the Fourier series  of $f(x)=(\pi-x)/2$ illustrating the Gibbs phenomenon.}\label{fig:Gibbs}
\end{figure}

\begin{figure}[htp]
\begin{scriptexample}[]{}
\begin{luacode*}
-- Fourier series
function partial_sum(n,x)
    partial = 0;
    for k = 1, n, 1 do 
        partial = partial + math.sin(k*x)/k 
    end;
    return partial
end
-- Code to write PGFplots data as coordinates
function print_partial_sum(n,xMin,xMax,npoints,option)
    local delta = (xMax-xMin)/(npoints-1)
    local x = xMin
    if option~=[[]] then
        tex.sprint("\\addplot["..option.."] coordinates{")
    else
        tex.sprint("\\addplot coordinates{")
    end
    for i=1, npoints do
        y = partial_sum(n,x)
        tex.sprint("("..x..","..y..")")
        x = x+delta
    end
    tex.sprint("}") -- We can write "};" and then it is not necessary to put ";" when used
end
\end{luacode*}
\newcommand\addLUADEDplot[5][]{\directlua{print_partial_sum(#2,#3,#4,#5,[[#1]])}}
\centering
\pgfplotsset{width=15cm, height=7cm}  
\begin{tikzpicture}\small
\begin{axis}[xmin=-0.2, xmax=31.6, ymin=-1.85, ymax=1.85, 
  xtick={0,5,10,15,20,25,30},
  ytick={-1.5,-1.0,-0.5,0.5,1.0,1.5},
  minor x tick num=4,
  minor y tick num=4,
  axis lines=middle,
  axis line style={-}
  ] 
%%\addplot[color=red] {pi/2-x/2};
% SYNTAX: Partial sum 30, from x = 0 to 10*pi, and sampled in 1000 points
\addLUADEDplot[color=blue,smooth]{30}{0}{10*math.pi}{1000};
\end{axis} 
\end{tikzpicture}
\begin{verbatim}
\begin{luacode*}
-- Fourier series
function partial_sum(n,x)
    partial = 0;
    for k = 1, n, 1 do 
        partial = partial + math.sin(k*x)/k 
    end;
    return partial
end
-- Code to write PGFplots data as coordinates
function print_partial_sum(n,xMin,xMax,npoints,option)
    local delta = (xMax-xMin)/(npoints-1)
    local x = xMin
    if option~=[[]] then
        tex.sprint("\\addplot["..option.."] coordinates{")
    else
        tex.sprint("\\addplot coordinates{")
    end
    for i=1, npoints do
        y = partial_sum(n,x)
        tex.sprint("("..x..","..y..")")
        x = x+delta
    end
    tex.sprint("}") -- We can write "};" and then it is not necessary to put ";" when used
end
\end{luacode*}
\end{verbatim}
\end{scriptexample}
\end{figure}

\section{Getting started}

For an introduction to the most important gotchas of \docAuxCommand{directlua}, see the guide \texttt{lualatex-doc.pdf}, which is available at ctan or possibly in your distribution.

Before presenting the tools in this package, let me insist that the best way to manage a nontrivial piece of Lua code is preferable to use an external file and source it from Lua, as explained in the cited document.

\LuaTeX communicates with TeX with only a few commands. We will explore these commands first.

\subsection{Basic print statements}

\begin{teXXX}
\directlua{tex.print}
\end{teXXX}

To print you can use the Lua command \lstinline{tex.print}.

The package \pkg{luacode}\cite{luacode} provides some further environments and commands catering for
variations in catcodes. 



The |\directlua| is useful to call functions that have been defined using Lua.

\begin{texexample}{luacode}{ex:luacode}
\begin{luacode}
function LineBreaks(T1,T2)
 local a = T1 .. "\\\\" .. T2 .. "\\par" -- T1\\\\T2\\par
 local b = [[ T1\\T2 ]]                  -- "T1"\\\\"T2"
 local c = T1 .. "\\newline " .. T2      -- T1\\newline T2
 local d = [[ T1\string\newline T2 ]]    -- "T1"\\newline "T2"
 tex.print(a,b,c,d)
 end
\end{luacode}

\def\testlinebreaks#1#2{%
\bgroup\parindent=0pt
    \directlua{LineBreaks("#1","#2")}%
\egroup}
\testlinebreaks{one}{two}
\testlinebreaks{three}{four}
\end{texexample}

The code in the example ensures that the code is escaped properly firstly for \tex as it will try and expand the
strings and then also not to allow any strings that need escaping in Lua. This is a double edge sword that caught me a number of times.


Lua can handle subtraction, negative numbers, numbers with decimal points, multiplication (using *),
division (using /), exponentiation (using |^|), and combinations of these. Here are some examples:
\emphasis{directlua, tex,print}


\section{Numbers}

The number type represents real (double-precision floating-point) numbers. Lua has no integer type, as it does not need it. There is a widespread misconception about floating-point arithmetic errors and some people fear that even a simple increment can go weird with floating-point numbers. The fact is that, when you use a double to represent an integer, there is no rounding error at all (unless the number is greater than 100,000,000,000,000). Specifically, a Lua number can represent any long integer without rounding problems.
We can write numeric constants with an optional decimal part, plus an optional decimal exponent. 

Examples of valid numeric constants are:
\begin{verbatim}
    4     0.4     4.57e-3     0.8e12     5e+20
\end{verbatim}

\begin{texexample}{Formatting numbers}{ex:fmtn}
\begin{luacode}
local str = string.format("%.2f",0.8e12)
print(str)
\end{luacode}
\end{texexample}



\subsection{Scientific notation}

You can also write numbers using the \textit{scientific notation}, where the prt before the upper multiplied by 10 to the power after $\textup{e}$

\begin{texexample}{Numbers scientific notation}{ex:scientific}

Some big numbers \directlua{tex.print(1.2193263111264E17 / 987654321)}

\end{texexample}


\section{Hexadecimal numbers}
Lua also understands hexadecimal (base 16) numbers, using the letters
a-f (or A-F) to represent 10 through 15. Hexadecimal numbers should start with \texttt{0x} or \texttt{0X}.

\begin{texexample}{Hexadecimal numbers}{ex:hex}
\directlua{tex.print(0XA)}
\end{texexample}


\section{Lua variables}

Lua variables are similar to those used by other computer languages, such as Python, Javascript and similar modern languages. They are untyped, which means they can easily produce subtle errors.

Programmers generally choose names for their variables that are meaningful—they document what the variable is used for.

Variable names can be as long as you like. They can contain almost any characters  but they can’t begin with a number. It is legal to use uppercase letters, but it is conventional to use only lower case for variable names.

\begin{texexample}{Lua Variables}{}
\luadirect{
  A = 2^0.5
  B = 42 
 local  pi = 3.141617
 tex.print(A+B-pi)
}
\end{texexample}

Variables unless they are preceded with a |local| are in the document global space. We can continue our example from above as we did not define A and B again, they are available in the next example.

\begin{texexample}{Lua Variables}{}
\luadirect{
   tex.print(A+B)
   
   local A,B = 1,1
   tex.print(A+B) 
}
\end{texexample}

\begin{texexample}{Lua Variables}{}
\luadirect{
   tex.print(A+B)
   
   local A,B = 1,1
   tex.print(A+B) 
}

\def\abadd#1#2{%
  \luadirect{
     A = #1 + #2
     tex.print(A)}
}

\abadd{100}{925.56}
\end{texexample}


Lua is case sensitive, which means |NUM|, |Num| and |num| are different variables.

\begin{texexample}{Lua Variables case sensitivity}{}
\directlua{
   NUM=1
   Num=2 
   num=3
   tex.print(NUM+Num+num)
}
\end{texexample}


\chapter{Statements}

Lua supports an almost conventional set of statements, similar to those in C,
Pascal or Go. Conventional statements include assignment, control structures,
and procedure calls. Lua also supports some not so conventional statements,
such as multiple assignments and local variable declarations

\section{Assignment}

Assignment is the basic means of changing the value of a variable or a table field.
\begin{verbatim}
a = "hello".."Lua"
b = 100.231
\end{verbatim}


\subsection{Multiple Assignment}

You can assign multiple values to multiple variables at the same time. You can also print multiple values
at the same time. The comma is used for both. Here's how you use the comma for multiple assignment, and for printing multiple values at the same time:

\begin{texexample}{Another example}{}
\directlua{
  Product, Exponent = 10*10, 999
  A,B=1,2
  tex.print(Product, Exponent)
  tex.print(A,B)
}
\directlua{
    A,B=1,2
    tex.sprint("A=" .. A, "B =" .. B)
}
\end{texexample}


\begin{texexample}{Multiple assignments}{ex:massign}
\begin{luacode}
local x1, x2, x3 = 16, 50, 33
local sum = x1^3 + x2^3 + x3^3
tex.print("sum = " .. sum)
\end{luacode}
\end{texexample}

Lua can be very useful in calculating and presenting the results in a nice way. In (\ref{ex:massign2}) we add additional \luacmd{tex.print} lines to calculate the sum.
Remember that we need to escape all backslasheses using (|\\|).

\begin{texexample}{Multiple assignments}{ex:massign2}
\begin{luacode}
local x1, x2, x3 = 16, 50, 33
local sum = x1^3 + x2^3 + x3^3
tex.print("\\[")
tex.print("16^3 + 50^3 + 33^3 = "..sum)
tex.print("\\]")
\end{luacode}
\end{texexample}
If you notice that the sum digits are made up of the digits of the numbers we have cubed.

Let us practice a bit more and get the next number in the series.

\begin{texexample}{Multiple assignments}{ex:massign2}
\begin{luacode}
local x1, x2, x3 = 16, 50, 33
local sum = x1^3 + x2^3 + x3^3
local sum1 = 166^3 + 500^3 + 333^3 
local sum2 = 1666^3 + 5000^3 + 3333^3
local sum3 = 16666^3 + 50000^3 + 33333^3
tex.print("\\begin{align}")
tex.print("16^3 + 50^3 + 33^3 &= "..sum.."\\\\")
tex.print("166^3 + 500^3 + 333^3 &= "..sum1.."\\\\")
tex.print("1666^3 + 5000^3 + 3333^3 &= "..sum2.."\\\\")
tex.print("16666^3 + 50000^3 + 33333^3 &= "..string.format("%.0f",sum3))
tex.print("\\end{align}")
\end{luacode}
\end{texexample}

The above pattern can be extended forever and the proof is available in 34. Writing it this way is not very efficient. In the next chapter we will write a function to make it easier to typeset and calculate these numbers. If you notice the last answer is in scientific notation. 

Multiple assignments are not faster than the equivalent single assignments. Sometimes they can be useful for swapping values such as |x, y = y, x|. A more frequent use is to collect multiple returns from function calls. For instance, in the assignmen |x,y = f()| the call to |f| returns two results: |a| gets the first and |b| is assigned the second.

\section{Local Variables and Blocks}

Lua provides a small and conventional set of control structures, with if for conditional
execution and while, repeat, and for for iteration. All control structures
have an explicit terminator: |end| terminates |if|, |for| and |while| structures; |until|
terminates |repeat| structures.

The condition expression of a control structure can result in any value. Remember
that Lua treats as true all values different from false and nil. (In
particular, Lua treats both zero and the empty string as true.)


\section{Conditionals}



\subsection*{if then else}

The \textit{if–then} construct (sometimes called \textit{if–then–else}) is common across many programming languages.
 
\begin{texexample}{Conditionals}{ex:conditionals}
\directlua{
 local a=3
 local b=12^2
 if a<b then 
   tex.sprint("$a<b^2$ "..a..", "..b) 
 else
 end
}
\end{texexample}

To write nested \textbf{if}s you can use \textbf{elseif}. It is similar to \luacmd{else} followed by \luacmd{if}, but it avoids the need for multiple \luacmd{end}s.

Lua does not have a switch statement and is common to find \luacmd{elseif} in expressions.

To test whether a variable is not |nil| in a conditional, it is terser to just write the variable name rather than explicitly compare against |nil|. Lua treats |nil| and |false| as |false| (and all other values as |true|) in a conditional:

\begin{texcode}{Idiomatic Lua conditionals}{ex:lua-condinional}
local line = io.read()
if line then  -- instead of line ~= nil
  ...
end
...
if not line then  -- instead of line == nil
  ...
end
\end{texcode}

However, if the variable tested can ever contain false as well, then you will need to be explicit if the two conditions must be differentiated: line == nil v.s. line == false.

and and or may be used for terser code:

\begin{texexample}{idiomatic Lua conditionals}{ex:cond}
\luadirect{
local function test(x)
  x = x or "idunno"
    -- rather than if x == false or x == nil then x = "idunno" end
  tex.print("YES!")
    -- rather than if x == "yes" then tex.print("YES!") else tex.print(x) end
end
  test()
}
\end{texexample}


\subsection*{while}

As the name implies, a \luacmd{while} loop repeats its body while a condition is true. As
usual, Lua first tests the while condition; if the condition is false, then the loop
ends; otherwise, Lua executes the body of the loop and repeats the process.

\begin{texexample}{while loop}{ex:loop}
\begin{luacode}
   counter = 1
   while counter <= 100 do
      tex.print(counter)
      counter = counter + 1
   end
\end{luacode}
\end{texexample}


\let\exec\directlua


\section{for}

The |for| statements has two variants: the \emph{numeric} |for| and the \emph{generic} |for|. The 
numeric |for| has the following syntax:
\begin{verbatim}
for var = exp1, exp2, exp3 do
  code...
end  
\end{verbatim}

This loop will execute the code for each value of |var| from from |exp1| to |exp2|, using
|exp3| as the step to increment |var|. This third expression is optional; when
absent, Lua assumes 1 as the step value. A typical example is shown in Example~\ref{ex:forloop}

\begin{texexample}{for loop}{ex:forloop}
\begin{luacode}
for n = 1, 59 do
   tex.print("\\(\\overline{"..n.."}\\), ")
end
\end{luacode}
\end{texexample}

The example is interesting, as it shows a notation used sometimes in Mathematical texts to denote numbers in sexagesimal systems. A sexagesimal system is an numeral system based on a base of 60, originally used by the Sumerians and then became known as Babylonian numbers. We still use it today to tell time and measure angles. The |\overline|, is just a notation to show it is not a decimal number but something else. In this case it represents one of the digits of a base 60 numeral system. More modern texts do not use the overline but simply the number. 

Let us print the example, this time grouping the numbers in units of 12. We will use the mod|%| operator and simply print a linebreak.

\begin{texexample}{for loop}{ex:forloop}
\begin{luacode}
for n = 1, 59 do
   tex.print("\\(\\overline{"..n.."}\\), ")
   if n%12==0 then 
      tex.print("\\\\")
   end 
end
\end{luacode}
\end{texexample}


\subsection{repeat until}

As the name implies, a repeat–until statement repeats its body until its condition
is true. This statement does the test after the body, so that it always
executes the body at least once.

\let\exec\directlua

\begin{texexample}{repeat until}{ex:repeat0}
\begin{luacode}
local  n, z = 1, 21
local  f = 1
  repeat
    tex.print(n + z)
    n = n + 1
    f = f + 10
  until f>=99
\end{luacode}
\end{texexample}

Unlike in most other languages, in Lua the scope of a local variable declared
inside the loop includes the condition:

\begin{texexample}{repeat-until}{ex:repeat1}
\begin{luacode}
local x = 19.7899
local sqr = x/2
local count = 0
repeat
   sqr = (sqr + x/sqr)/2
   local error = math.abs(sqr^2 - x)
   count = count + 1
   print("count = "..count.." square root = "..sqr.." error = "..error)
until error < x/10000 or count > 100-- local 'error' still visible here
\end{luacode}
\end{texexample}


\subsection{The break and do Statements}
\begin{texexample}{Break and do}{ex:breakanddo}
\exec{
for N = 1, 10 do
 if N > 5 then
 break
 end
 tex.print(N)
 end
}
\end{texexample}

\chapter{Functions}

\cxset{epigraph width=0.6\textwidth,
       epigraph text align=left}
\epigraph{“A computer is like a violin. You can imagine a novice trying fist a phonograph and then a violin. The latter, he says, sounds terrible. That is the argument we have heard from our humanists and most of our computer scientists. Computer programs are good, they say, for particular purposes, but they aren't flexible. Neither is a violin, or a typewriter, until you learn how to use it.” }{Marvin Minsky}


\section{What are functions}

The main mechanism for abstraction of statements and expressions in Lua are \textit{functions}. Function carry out specific tasks. In other languages sometimes they are called a \textit{procedure} or a \textit{subroutine}. Functions are first class citizens in Lua. They can be used both as statements or as expressions. All functions in Lua are anonymous. This is not immediately clear in the standard syntax for defining a function
\begin{verbatim}
function add (x,y)
  return x + y
end  
\end{verbatim}
Nevertheless, this syntax is just syntactic sugar for an assignment of an anonymous function to a variable\footnote{Since Lua version 3.1}
\begin{verbatim}
add = function (c, y)
  return x + y
end  
\end{verbatim}
That is, the code creates an anonymous function and assigns it to the global
variable add. Therefore, all functions in Lua are anonymous, like in Scheme.
A \enquote{name} for a function is actually the name for a variable that holds that
function.

\begin{texexample}{Functions used in expressions}{ex:expressions}
\begin{luacode}
  a = math.sin(2) + math.cos(10)
  tex.print(a)
\end{luacode}
\end{texexample}

The arguments are enclosed in parentheses denoting a call. If the function does not have any arguments, we must still call it with an empty list () to denote the call.

Let us return to our example with the numbers. Using a function we will try and generalize the problem.

Given three integer values typeset a curious number.

\begin{texexample}{Curious Numbers}{ex:curfunction}
\begin{luacode}
function curious(x1, x2, x3)
   local sum = x1^3 + x2^3 + x3^3
   local str = tostring(x1).."^3 + "..tostring(x2).. "^3 + ".. 
               tostring(x3) .."^3& =".. 
               string.format("%.0f",sum) 
   return str
end

print("\\begin{align}")
print(curious(1666,5000,3333))
print("\\end{align}")
\end{luacode}
\end{texexample}


\section{Fixed Parameters}

The default convention for passing parameters to a function is using fixed parameters. These tell
the function how many parameters there will be and the order of the parameters. When using fixed
parameters , you know what to expect from the function, and based on the values of the parameters
passed, you can take appropriate action.

\begin{texexample}{An example}{}
\begin{luacode}
print=tex.print
function listParams(one, two, three)
print( "We got :", one, two, three)
if one=="Q" then
  tex.print("\\textls{The letter Q}")
else
  tex.print("Other letter")
end
end
listParams("Q", "Q", "R")
\end{luacode}
\end{texexample}


\section{Multiple Results}

An unconventional, feature of Lua is that functions can return multiple results. Many predefined functions in Lua return multiple values. 

Example \ref{ex:functions} has two parameters and returns the average of these numbers.

\begin{texexample}{Functions}{ex:functions}
\exec{
function Average(Num1, Num2)
    return (Num1 + Num2) / 2
end
tex.print(Average(10,12))
}
\end{texexample}

Here is one that prints the Ackerman function. This is an interesting function as the value grows very quickly and can cause a stack overflow. It can also slow compilation quite a bit for higher values. ack(4,1) will cause a stack overflow. Whereas ack(3,11) compiles giving a value of 16381 ack(3,12) causes a stack overflow.  

\[
\begin{matrix}
   a\uparrow\uparrow b & = {\ ^{b}a}  = & \underbrace{a^{a^{{}^{.\,^{.\,^{.\,^a}}}}}} & 
   = & \underbrace{a\uparrow (a\uparrow(\dots\uparrow a))} 
\\  
    & & b\mbox{ copies of }a
    & & b\mbox{ copies of }a
  \end{matrix}
\]

\[
\begin{bmatrix}
   a\times b & = & \underbrace{a+a+\dots+a} \\
   & & b\mbox{ copies of }a
\end{bmatrix} 
\]


\begin{texexample}{The ackerman function}{ex:ackerman}
\exec{
function ack(M,N)
    if M == 0 then return N + 1 end
    if N == 0 then return ack(M-1,1) end
    return ack(M-1,ack(M, N-1))
end
tex.sprint(ack(3,11))
}
\end{texexample}


\subsection{Returning multiple values}

This return an error if Arg1 is a number

\begin{texexample}{Return multiple arguments}{ex:multargs}
\exec{
function ReturnArgs(Arg1, Arg2, Arg3)
  return Arg1, Arg2, Arg3
end
tex.sprint(ReturnArgs("aaaa", 2, 3))
   
function Fact(N)
  local Ret = 1
  for I = 1, N do
    Ret = Ret * I
  end
  return Ret
  end
tex.print(Fact(10))
}
\end{texexample}


\begin{texexample}{Factorial}{ex:luafac}
\exec{
function Fact(N)
  local Ret = 1
  for I = 1, N do
    Ret = Ret * I
  end
  return Ret
  end
tex.print(Fact(10))
}
\end{texexample}

\subsection{Anonymous Functions}

Anonymous functions do not have a function name and can be assigned to a variable. 

\begin{texexample}{Anonymous Functions}{ex:anonymous}
\exec{
(function(A, B)
   tex.print(A + B^2)
 end)(2, 3)
}
\end{texexample}

\section{Using Library Functions and Methods}

\begin{texexample}{Big Numbers}{ex:bignum}
\begin{luacode}
require("BigNum")
ret = BigNum.new("1")
for i=1, 60 do
  ret = ret*i
end
local res = BigNum.mt.tostring(ret)

local str,token = "",""
for token in string.gmatch(res, (".")) do
   str = str..token.."\\hskip1sp "
end

print("63! = "..str)
\end{luacode}
\end{texexample}

Palindromic numbers that read the same both ways (left-to-right and right-to-left), 
e.g., 12321 or 9210129 are number theory curiosities.

All numbers in any base with one digit are palindromic. The number of palindromic numbers with two digits is nine.

\begin{gather}
\{11,22,33,44,55,66,77,88,99\}
\end{gather}

Let us find some of them.

\begin{texexample}{Palindromic Numbers}{ex:pal}
\begin{luacode}
require("BigNum")

function pallindrome(n,topower)
  local n1 = BigNum.new(n)
  n2 = n1^topower
  return n2
end


tpallindrome3 = {101,111,10101,11011,110011,1001001,2201}
tpallindrome2 = {26,264,307,836} 

print("\\begin{align}")
for _,v in pairs(tpallindrome2) do
  pl = pallindrome(v,2)
   print(v.."^".."2".." &= "..BigNum.mt.tostring(pl).."\\\\")
end 
for k,v in pairs(tpallindrome3) do
  pl = pallindrome(v,3)
  if next(tpallindrome3,k)==nil then
    str=""
  else
    str="\\\\"
  end  
  print(v.."^".."3".." &= "..BigNum.mt.tostring(pl)..str)
end 
print("\\end{align}")

-- largest non-palindromic number whose square is a palindrome
local lp = pallindrome("831775153121251039203514",2)
print(lp)

\end{luacode}
\end{texexample}

The construction
\begin{verbatim}
if next(tpallindrome3,k)==nil then
    str=""
  else
    str="\\\\"
  end 
\end{verbatim}
is to ensure that we do not have a carriage return |\\| at the last equation of align. 

The number 2,201 is truly amazing as it is the only non-palindromic number that its cube is palindromic and is shown in our example as having the value \num{10662526601}. This number appeared in a number of Martin Gardner's books.





\section{First Class Functions}

A language has first-class functions if it can do for each of the following without recursively invoking a compiler or interpreter. In languages with first-class functions, the names of functions do not have any special status; they are treated like ordinary variables with a function type.[3] The term was coined by Christopher Strachey in the context of \enquote{functions as first-class citizens} in the mid-1960s.

\begin{enumerate}
\item Create new functions from pre-existing functions at run-time.
\item Store functions in collections.
\item Use functions as arguments to other functions.
\item Use functions as return values of other functions.
\end{enumerate}

\section*{Primes}

Continuing our exploration of Lua and number theory we will use a longer example using \textit{prime numbers}. My basic reference for this is Stewart's \textit{Theory of Numbers}\footcite{stewart1964}.

In 1876 Lucas was able to show that the number $M_{127}$ is a prime and for a very long time it remained the largest number to be a prime. For more extended numerical investigations in pre-computer era two books by D.N.Lehmer provded
tables of primes to around 10,000,000.00.\footnote{\textit{Factor table for the first ten millions containing the smaller factor of every number not divisible by 2,3,5 and 7 between the limits 0 and 10,017,000.} Carnegie Institution of Washington Publication 105, 1909.\par \textit{List of prime numbers from 1 to 10,006,721.} Carnegie Institution of Washington Publication 165, 1914.} Useful  as they were, such tables are, of course, inadequate to handle problems like the one proposed by Lucas 1867.

In Example~\ref{ex:primesmore} we will first write a function that formats a number with commas and then calculate 
M127.

\begin{texexample}{Lucas M127}{ex:primesmore}
\begin{luacode}
function formatnum(n) -- credit http://richard.warburton.it
	local left,num,right = string.match(n,'^([^%d]*%d)(%d*)(.-)$')
	return left..(num:reverse():gsub('(%d%d%d)','%1,'):reverse())..right
end

local n1 = BigNum.new(2)
local bnum = BigNum.mt.tostring
n2 = n1^127-1
print(formatnum(bnum(n2)).."\\\\")

str = string.format("%.0f", tostring(2^127))
print(formatnum(str))
\end{luacode}
\end{texexample}

The most widely used method for preparing alist of prime numbers less than a given limit is a device ascribed to Eratosthenes (276-194 B.C.). One starts  by writing down a list of the integes from 2 to that limit and then in a sytematic way eliminating all the composite integers. The method as described by Stewart is as follows:

\begin{quotation}
For example, with a limit of n = 100, we first set down a list of the 
integers from 2 to 100. Recognizing that 2 is a prime, but that all proper 
multiples of 2 are composite, we cross out 4,6,8,..., 100. The next number 
not crossed out is 3, which must be a prime for the only possible proper 
factor is 2, and 3 is not a multiple of 2 else it would have been crossed out. 
Recognizing that all proper multiples of 3 are composite, we cross out 
6, 9, 12,..., 99—although it is not actually necessary to cross out 6, 12, 
18,..., 96 again, since they are already crossed out, being multiples of 2. 
The next number not crossed out is 5; this number must be a prime, for if 
it were composite, it would have to have as a proper factor a prime less 
than 5, namely, either 2 or 3; but since 5 is not crossed out, it is not a 
multiple of 2 or 3. Crossing out all multiples of 5, not previously crossed 
out, namely: 25, 35, 55, 65, 85, 95, we find, by the same reasoning as 
before, that the next number not crossed out must be a prime; it is 7. 
The only multiples of 7, not previously crossed out, are 49, 77, 91, and 
these we now cancel. Now, unless we have been analyzing the sieve process 
carefully, we are due for a surprise—all the remaining numbers which 
have survived the sieve are primes! The sieve appears as follows: 
\end{quotation}

Our first concern is to first develop functions to typeset such tables and once the
typesetting is out of the way to then implement the sieve. In current computer terminology
a sieve is a filter.

We will represent a single number in this table as a tuple (n, f) where $f$ is a boolean indicating if the
number is to be crossed out or not.

\begin{texexample}{Eratosthenes Sieve I}{ex:eratosthenes}
\begin{luacode}
local T = {}
local num = {}
function eratosthenes (n)
   for i=1,n do
     num[i]=false
     table.insert(T,num)
   end
end

eratosthenes(100)

function print_eratosthenes()
  for k,v in pairs(T) do
    if k>1 then print("\\mbox{"..k.."} ") 
    else
      print("\\mbox{~~~} ")
    end
    if k%20==0 then print("\\\\") end
  end
end  
print_eratosthenes()
\end{luacode}
\end{texexample}

Our first skeleton program is shown above and consists of two functions, |eratosthenes| and |print_eratosthenes|. The first at this stage just initializes the table with all the elements having a false value, and to the second function we delegate the printing. The result did not come out very well due to using |mbox|. It will be preferable to use a fixed width box or we could use a LaTeX tabular environment or even draw the cells using \tikzname or use a packae such as tcolorbox. At this stage we also need to decide if we need to use a strike to indicate the numbers eliminated or simply use color. It would be better to rather write anothe function to decorate the cell and provide an option.

In the next example we add the function |mbox| and also we use the \pkg{cancel}\footcite{cancel} to strike through the
numbers. This will produce identical results to the previous example with all the numbers cancelled. In the final
example we will implement the sieve.

\begin{texexample}{Sieve}{ex:sieve2}
\begin{luacode}
local T = {}
local num = {}
function eratosthenes (n)
   for i=1,n do
     num[i]=true
     table.insert(T,num)
   end
end

eratosthenes(100)

function mbox(n,tf)
  local nstr = "$"..tostring(n).."$"
  if tf then nstr="$\\cancel{"..n.."}$" end
  return "\\mbox{"..nstr.."}"
end

function print_eratosthenes(f)
  for k,v in pairs(T) do
    if k>1 then print(f(k,v[1])) 
    else
      print("\\mbox{~~~} ")
    end
    if k%20==0 then print("\\\\") end
  end
end  


print_eratosthenes(mbox)
\end{luacode}
\end{texexample}

Note than |print_eratosthenes| now takes one argument |f| which is a function.


\begin{texexample}{Sieve}{ex:sieve2}
\begin{luacode}
local T = {}
local num = {}
function eratosthenes (n)
   for i=1,n do
     num[i]=true
     table.insert(T,num)
   end
end

eratosthenes(100)

function mbox(n,tf)
  local nstr = "$"..tostring(n).."$"
  if tf then nstr="$\\cancel{"..n.."}$" end
  return "\\mbox{"..nstr.."}"
end

function tcbox(n,tf)
  local nstr = "$"..tostring(n).."$"
  if tf then nstr="$\\cancel{"..n.."}$" end
  return "\\tcbox[nobeforeafter,boxsep=0.5pt,boxsep=0.5pt,right=1pt,left=1pt,width=3em,]{\\hbox to 1.5em{"..nstr.."}}"
end

function print_eratosthenes(f)
  for k,v in pairs(T) do
    if k>1 then print(f(k,v[1])) 
    else
      print(f(1,v[1]))
    end
    if k%20==0 then print("\\\\") end
  end
end  


print_eratosthenes(mbox)

print_eratosthenes(tcbox)
\end{luacode}
\end{texexample}


On my computer in takes about 3s to compute the primes up to 10 million and 55s to compute to 100 million.

\section*{Mersenne Numbers}

A number is called a Mersenne number if it is in the form:

\begin{gather}
 M_p = 2^p-1
\end{gather}
where $p$ is a prime . If a Mersenne number $M_p = 2^p-1$ is a prime. then it is
called a \textit{Mersenne prime}.



\section{Summary}




\chapter{Working with Lua Tables}

This section explores a new data type called a table. It's a data structure, which means that it lets
you combine other values. Because of its flexibility, it is Lua’s only data structure. (It is possible to
create other, special-purpose data structures in C.)
\begin{phdverbatim}
\begin{filecontents*}{test.lua}
  hash = {}
  hash[ "key-1" ] = "val1"
  hash[ "key-2" ] = 1
  hash[ "key-3" ] = {}
  tex.sprint(hash["key-2"])
\end{filecontents*}
\directlua{dofile("test.lua")}
\end{phdverbatim}


\section{Using dofile}

Although using \lstinline{directlua} has been a useful function so far, this is limiting in many respects.

\begin{verbatim}
\begin{filecontents*}{test.lua}
 function test(N)
  return N
end
tex.print(test(5))
\end{filecontents*}
\end{verbatim}

\begin{texexample}{Working with lua file}{ex:dofile}
 function test(N)
   return N
 end
 tex.print(test(5))
\end{texexample}

As we want to keep ourselves within a document, rather than a separate file, we
use the \verb+filecontents+ package to save a lua file on disc and then use it with
\lstinline{dofile}.

\begin{phdverbatim}
\begin{filecontents*}{test.lua}
hash = {}
hash[ "key-1" ] = "val1"
hash[ "key-2" ] = 1
hash[ "key-3" ] = {}
hash[" key-3"] = {}
\end{filecontents*}
\directlua{dofile("test.lua")}
\end{phdverbatim}

The keys can include spaces. If you have to automate the key generation, ensure that the keys are trimmed.

\directlua{dofile("test.lua")}
%\begin{tcblisting}{}
%\begin{filecontents*}{test.lua}
%Squares = {} -- A table constructor can be empty.
% for I = 1, 5 do
%   Squares[I] = I ^ 2
% end
% for I = 1, 5 do
%   tex.sprint(I .. " squared is " .. Squares[I].."\\\\")
% end
%\end{filecontents*}
%\directlua{dofile("test.lua")}
%\end{tcblisting}
%
%
%\begin{tcblisting}{}
%\begin{filecontents*}{test01.lua}
% NameToInstr = {John = "rhythm guitar",
% Paul = "bass guitar",
% George = "lead guitar",
% Ringo = "drumkit"}
% for Name, Instr in ipairs(NameToInstr) do
%   tex.sprint(Name)
% end
%\end{filecontents*}
%\directlua{dofile("test01.lua")}
%\end{tcblisting}


Using tables that contain functions is a handy way to organize functions, and Lua keeps many of its
built-in functions in tables, indexed by strings. For example, the table found in the global variable table
contains functions useful for working with tables. If you assign another value to table, or to one of the
other global variables used to store built-in functions, the functions won’t be available anymore unless
you put them somewhere else beforehand. If you do this accidentally, just restart the interpreter



\subsection{table.sort}
\begin{texexample}{Sorting}{lua:sort}
\begin{luacode}
Names = {"Scarlatti", "Telemann", "Corelli", "Purcell",
   "Vivaldi", "Handel", "Bach","Yiannis"}
table.sort(Names)
 for I, Name in ipairs(Names) do
   tex.sprint(I.." ".. Name.."\\par")
 end
\end{luacode}
\end{texexample}


%\endinput
%
%\subsection{table.concat}
%\subsection{table.sort}
%\begin{texexample}{Lua Sort}{}
%\begin{luacode}
%require "lualibs"
%-- require "luasql.mysql"
%-- commas (and spaces):
% function CommaSeparate(Arr)
%   return table.concat(Arr, ", ")
% end
% tex.print(CommaSeparate({"a", "bc", "d"}))
% FileStr = os.tmpname()
%    tex.sprint("\\string"..os.tmpname().." \\% temporary file name")
% Hnd = io.open(FileStr, "w")
% if Hnd then
%   tex.sprint("Opened temporary file ", FileStr, " for writing\n")
%   Hnd:write("Line 1\nLine 2\nLine 3\n")
%Hnd:close()
%for Str in io.lines(FileStr) do
%  io.write(Str, "\n")
%end
%  os.remove(FileStr)
%else
%   io.write("Error opening ", FileStr, " for writing\n")
%end
%\end{texexample}



\chapter{Packages}
The \pkg{luacode} package provides commands to make entering of code from a \TeX
file easier. It provides a better escape mechanism

\emphasis{luaexec,luacode}
\begin{texexample}{luaexec}{ex:exec}
\def\foo{156789.0001}
\(
 \luaexec{
 texio.write_nl("Special chars: _ ^ & $ { } ~ working.\string\n"
 .. "Backslashes still need a bit of care.\string\n"
 .. "Single sharps are easier now: \#")
  % a tex comment: we also get a % below
 tex.sprint("\\pi \\neq ", tostring(math.pi):gsub('\%.', '+'))
 % we can use TeX macros
tex.sprint("-", math.sqrt(\foo))
 }
\)
\end{texexample}


\section{Using \texttt{luacode}}

One very useful environment is \refEnv{luacode}.

\begin{docEnvironment}{luacode}{}
The luacode environment is similar to luaexec. You need to be careful to pass a macro that is fully expandable in order to work properly.
\end{docEnvironment}

\begin{texexample}{luacode environment}{ex:luacode}
\edef\foo{156789.0001}
\[
 \begin{luacode}
    tex.sprint("a=", math.sqrt(\foo),"+ z^3")
 \end{luacode}
\]
\end{texexample}

\section{Creating new environments}
\emphasis{luacode,endluacode,tex}
If you need to create new environment you will have to use the \lstinline!\luacode...\endluacode! form  rather than the begin...end.




\chapter{Finding where everything is}

One of the most frustrating things when you starting with a new language, is to find out where
everything is and if the various paths are correct. The snippet below does just that. It tests for a file using \lstinline!kpse.find_file!
\bigskip

%\emphasis{kpse,find}
%\begin{tcblisting}{}
%\begin{filecontents}{atest.tex}
%\end{filecontents}
%\begin{luacode}
%  -- kpse.set_program_name("lualatex")
%  -- uncomment if having problems
%  local file = "phd.dtx"
%  local path = kpse.find_file(file, '.dtx')
%    if path==nil then
%     tex.tprint({"\\color{red}"},{"File not found!"})
%   else
%     tex.tprint({path})
%   end
%\end{luacode}
%\end{tcblisting}

In the example, we created a small file on the fly, using \lstinline!filecontents! package. Then we test using \lstinline!kpse.find_file!. It returns true and we print the full path.

\subsection{the os library}
Getting the operating system type and name
\emphasis{kpse,find,require,os,name,lualibs,type}
\begin{tcblisting}{}
\begin{filecontents}{atest.tex}
\end{filecontents}
\begin{luacode}
  -- get the os name
  require("lualibs-os")
  local G,Y=os.name,os.type
  tex.tprint({G.."\\par"},{Y.."\\par"})
\end{luacode}
\end{tcblisting}

Gettting the runtime of a program

\begin{texexample}{}{}
\begin{filecontents}{atest.tex}
\end{filecontents}
\begin{luacode}
  -- get the os name
  require("lualibs-os")
  tex.print (">> ",os.runtime()," ms")
  tex.print({-2,os.uuid()})
  tex.print({-2,os.tmpname()})
\end{luacode}
\end{texexample}



\subsection{uuid}
\emphasis{os,uuid}
Getting a uuid or a slight variant of it we use \lstinline!os.uuid()!



\section{Reading from a file}

|\usepackage{luatextra}|


\begin{filecontents}{testdata10.dat}
  A  B
  1.0 20
  1.1 21
  1.2 22
\end{filecontents}
%
%\begin{texexample}{Reading from files}{ex:readfile}
%\begin{luacode*}
%function readtextfile()
%    file = io.open("testdata10.dat", "r")
%    for line1 in file:lines() do
%      --print(line1)
%      tex.print(line1)
%    end
%    file:close()
%end
%\end{luacode*}
%\directlua{readtextfile()}
%\end{texexample}
%
%\end{document}

\section{Further reading}

\begin{enumerate}
\item  Really nice introductory article ar \url{https://lwn.net/Articles/731581/}
\item   \url{https://lwn.net/Articles/640302/}
\item  News on Lua \url{https://luadigest.immortalin.com/}
\end{enumerate}










