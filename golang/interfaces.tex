\chapter{Interfaces}

Interface types express generalizations or abstractions about the behaviors of other types. By
generalizing, interfaces let us write functions that are more flexible and adaptable because they
are not tied to the details of one particular implementation.

Many object-oriented languages have some notion of interfaces, but what makes Go’s interfaces
so distinctive is that they are satisfied \textit{implicitly}. In other words, there’s no need to
declare all the interfaces that a given concrete type satisfies; simply possessing the necessary
methods is enough. This design lets you create new interfaces that are satisfied by existing
concrete types without changing the existing types, which is particularly useful for types
defined in packages that you don’t control.

In this chapter, we’ll start by looking at the basic mechanics of interface types and their values.
Along the way, we’ll study several important interfaces from the standard library. Many Go
programs make as much use of standard interfaces as they do of their own ones. Finally, we’ll
look at type assertions (§7.10) and type switches (§7.13) and see how they enable a different
kind of generality.

\begin{minted}[bgcolor=black!3!white, fontsize=\small]{go}
package main

import "fmt"

type Person struct {
	Name string
	Age  int
}

func (p Person) String() string {
	return fmt.Sprintf("%v (%v years)", p.Name, p.Age)
}

func main() {
	a := Person{"Arthur Dent", 42}
	z := Person{"Zaphod Beeblebrox", 9001}
	fmt.Println(a, z)
}
\end{minted}